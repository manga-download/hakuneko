<link rel="import" href="../../polymer/polymer-element.html">
<link rel="import" href="../../polymer/lib/elements/dom-if.html">
<link rel="import" href="theme.html">

<dom-module id="hakuneko-jobs">

    <template>
        <style include="theme"></style>
        <style>
            :host {
                width: 100%;
                background-color: var(--job-control-background-color);
            }
            .bar {
                display: flex;
                flex-direction: row;
                padding: 0.25em;
            }
            .expander {
                flex: 0;
                padding: 0.25em;
            }
            .status {
                flex: 1;
                text-align: right;
                padding: 0.25em;
            }
            .button {
                cursor: pointer;
            }
            .buttonQueued {
                color: var(--job-list-button-queued-color);
            }
            .buttonDownloading {
                color: var(--job-list-button-downloading-color);
            }
            .buttonCompleted {
                color: var(--job-list-button-completed-color);
            }
            .buttonFailed {
                color: var(--job-list-button-failed-color);
            }
            .list {
                height: 8em;
                background-color: var(--job-list-background-color);
                overflow-y: scroll;
            }
            .list table {
                width: 100%;
                table-layout: fixed;
                border-spacing: 0;
                border-collapse: collapse;
            }
            .list td {
                cursor: default;
                border-bottom: var(--job-list-row-border);
            }
            .cell {
                padding-left: 0.25em;
                padding-right: 0.25em;
                overflow: hidden;
                white-space: nowrap;
                text-overflow: ellipsis;
            }
            .progress {
                width: 4em;
            }
            .show {
                display: block ;
            }
            .hide {
                display: none;
            }
            .update-bookmark-chapters {
                padding-left: 1em;
            }
            .far.update-bookmark-chapters-status.active {
                color: var(--update-bookmark-chapters-disabled-color) !important;
            }
            .toggle-bookmark-chapters-update {
                margin-top: 1.5em !important;
                font-size: 0.8em !important;
                margin-left: 2.2em!important;
            }
            .toggle-bookmark-chapters-update.active {
                color: var(--update-bookmark-chapters-stop-color) !important;
            }
        </style>
        <div class$="list [[ getListClass(popupVisibility) ]]">
            <table cellpadding="0">
                <template is="dom-repeat" items="[[ jobList ]]" initial-count="500" target-framerate="5">
                    <tr title$="[[ item.labels.connector ]]&#10;[[ item.labels.manga ]]&#10;[[ item.labels.chapter ]]">
                        <td class="fa-fw"><i class$="fas [[ getStatusClass(item.status) ]] fa-fw" title$="[[ getErrorTitle(item.errors) ]]" on-click="restartDownload"></i></td>
                        <td class="cell">[[ item.labels.connector ]]</td>
                        <td class="cell">[[ item.labels.manga ]]</td>
                        <td class="cell">[[ item.labels.chapter ]]</td>
                        <td class="progress" style$="background: linear-gradient(90deg, var(--job-list-progress-color) [[ item.progress ]]%, var(--job-list-progress-background-color) 0%);"></td>
                    </tr>
                </template>
            </table>
        </div>
        <div class="bar">
            <div class="expander">
                <i class$="fas [[ getButtonClass(popupVisibility) ]] button" title="Toggle download list" on-click="toggleJobList"></i>
            </div>
            <div class="update-bookmark-chapters" title$="[[ getUpdateBookmarkChaptersTitle(updateBookmarkChaptersStatus) ]]">
                <span class="button fa-stack fa-xs" on-click="onUpdateBookmarkChaptersClick">
                    <i class$="far fa-arrow-alt-circle-down fa-stack-2x update-bookmark-chapters-status [[ getUpdateBookmarkChaptersActiveClass(updateBookmarkChaptersStatus) ]]"></i>
                    <template is="dom-if" if="[[ updateBookmarkChaptersStatus ]]">
                        <i class="fas fa-fw fa-circle-notch fa-stack-2x fa-spin"></i>
                        <i class="fas fa-suberlay fa-stop-circle toggle-bookmark-chapters-update active"></i>
                    </template>
                </span>
                <template is="dom-if" if="[[ updateBookmarkChaptersStatus ]]">
                    <span class="update-bookmark-chapters-status" title$="[[ updateBookmarkChaptersStatus.details ]]">[[ updateBookmarkChaptersStatus.status ]]</span>
                </template>
            </div>
            <div class="status">[[ jobList.length ]] Download(s)</div>
        </div>
    </template>

    <script>
        /** @polymerElement */
        class HakunekoJobs extends Polymer.Element {
            /**
             *
             */
            static get is() {
                return 'hakuneko-jobs';
            }

            /**
             *
             */
            static get properties() {
                return {
                    settings: {
                        type: Object,
                        value: undefined,
                        notify: true, // enable upward data flow,
                        //readOnly: true, // prevent downward data flow
                        //observer: 'onSelectedMangaChanged'
                    },
                    updateBookmarkChaptersStatus: {
                        type: Object,
                        value: undefined,
                        notify: true, // enable upward data flow,
                        //readOnly: true, // prevent downward data flow
                        //observer: 'onSelectedMangaChanged'
                    },
                };
            }

            /**
             *
             */
            ready() {
                super.ready();
                // HACK: electron specific code should not be added to UI elements, but due to the
                //       close confirmation bug this workaround is currently the best solution...
                this.ipc = require( 'electron' ).ipcRenderer;
                this.popupVisibility = false;
                this.jobList = [];
                // register callbacks for events published by download manager
                Engine.DownloadManager.addEventListener('updated', this.onDownloadStatusUpdated.bind(this));
                Engine.MangaUpdateManager.addEventListener('progress', this.onUpdateBookmarkChaptersProgress.bind( this ));
                this.ipc.on( 'close', this.onClose.bind( this ) );
                // HACK force evaluating property updateBookmarkChaptersStatus (to properly update title attributes in HTML)
                this.notifyPath('updateBookmarkChaptersStatus', {});
                this.notifyPath('updateBookmarkChaptersStatus', undefined);
            }

            /**
             *
             */
            toggleJobList() {
                this.set( 'popupVisibility', !this.popupVisibility );
            }

            /**
             * CSS class for the job list.
             * The CSS class depends on the current visibility state.
             */
            getListClass( visibility ) {
                return (visibility ? 'show' : 'hide');
            }

            /**
             * CSS class for the show/hide button of the job list.
             * The CSS class depends on the current visibility state.
             */
            getButtonClass( visibility ) {
                return (visibility ? 'fa-window-close' : 'fa-chart-bar'); // fa-tasks
            }

            /**
             * CSS class for the status of a job in the job list.
             * The CSS class depends on the curent status of the job.
             */
            getStatusClass( status ) {
                switch ( status ) {
                    //case 'unavailable':
                    //    return 'fa-exclamation-triangle';
                    //case 'available':
                    //    return 'fa-cloud';
                    case 'queued':
                        return 'fa-clock buttonQueued';
                    case 'downloading':
                        return 'fa-exchange-alt buttonDownloading';
                    case 'completed':
                        return 'fa-check button buttonCompleted';
                    case 'failed':
                        return 'fa-exclamation-triangle button buttonFailed';
                    default:
                        return '';
                }
            }

            /**
             *
             */
            getErrorTitle( errors ) {
                return ( errors && errors.length > 0 ? 'Click to re-download\n' : '' ) + errors.map( ( error ) => {
                    return error.toString();
                }).join( '\n' );
            }

            /**
             *
             */
            restartDownload( e ) {
                let job = e.model.item;
                if( job.status === 'failed' || job.status === 'completed' ) {
                    Engine.DownloadManager.addDownload( job.chapter );
                }
            }

            /**
             *
             */
            onDownloadStatusUpdated( e ) {
                let job = e.detail;
                let index = this.jobList.indexOf( job );
                if( index > -1 )  {
                    // force an UI update of the changed job
                    this.notifyPath( 'jobList.' + index + '.status' );
                    this.notifyPath( 'jobList.' + index + '.progress' );
                    if( job.status === 'completed' ) {
                        this.splice( 'jobList', index, 1 );
                    }
                    if( job.status === 'failed' && job.errors && job.errors.length > 0 ) {
                        this.notifyPath( 'jobList.' + index + '.errors' );
                    }
                } else {
                    // remove similar job that failed
                    let position = this.jobList.findIndex( (item) => {
                        return job.isSame( item );
                    });
                    if( position > -1 && this.jobList[position].status === 'failed' ) {
                        this.splice( 'jobList', position, 1 );
                    }
                    // add new job
                    if( job.status === 'queued' || job.status === 'downloading' ) {
                        this.push( 'jobList', job );
                    }
                }
            }

            getUpdateBookmarkChaptersTitle( updateBookmarkChaptersStatus ) {
                return (updateBookmarkChaptersStatus ?
                          updateBookmarkChaptersStatus.canceled ?
                              'Canceling...' :
                              'Click to cancel updating chapters for bookmarked mangas' :
                          'Start updating new chapters for bookmarked mangas'
                );
            }

            getUpdateBookmarkChaptersActiveClass( updateBookmarkChaptersStatus ) {
                return updateBookmarkChaptersStatus ? 'active' : 'inactive';
            }

            onUpdateBookmarkChaptersClick() {

                if( Engine.MangaUpdateManager.isUpdating ) {

                    Engine.MangaUpdateManager.cancelUpdate();
                    let msg = 'Canceling ... ' + (this.updateBookmarkChaptersStatus? this.updateBookmarkChaptersStatus.status : '');
                    let updateStatus = { canceled: true, status: msg, details: msg };
                    this.set('updateBookmarkChaptersStatus', updateStatus);
                    return;
                }

                Engine.MangaUpdateManager.updateAllMangas().then(() => {

                    console.info('downloaded new chapters!');

                } ).catch( error => {

                    console.error('error while trying to download new chapters: ', error);

                });
            }

            /**
             *
             */
            onUpdateBookmarkChaptersProgress( e ) {

                let data = e.detail;
                if( data.complete){
                   this.set('updateBookmarkChaptersStatus', undefined);
                } else {

                  let updateStatus = {
                    status: '',
                    details: '',
                  };

                  if ( typeof data.current === 'number' ) {
                      updateStatus.status = data.current + ' / ' + data.total;
                      let action = data.state === 'step'? 'Updating bookmarked mangas:' : data.state.toUpperCase();
                      updateStatus.details += action + ' ' + updateStatus.status + '\n';
                  }

                  updateStatus.details += data.mangaTitle? data.mangaTitle : '';
                  if( data.connectorTitle ) {
                    updateStatus.details += '\n' + data.connectorTitle;
                  }

                  if ( ! updateStatus.details || data.state === 'error') {
                    updateStatus.details = `[${data.state}] ` + updateStatus.details;
                  }

                  if( updateStatus.status ) {
                    updateStatus.status = updateStatus.status.trim();
                  }
                  if ( updateStatus.details ) {
                    updateStatus.details = updateStatus.details.trim();
                  }

                  this.set('updateBookmarkChaptersStatus', updateStatus);
                }
            }

            /**
             *
             */
            async onClose( event ) {
                // check if any job is running
                let index = this.jobList.findIndex( job => {
                    return ( job.status === 'queued' || job.status === 'downloading' );
                } );
                if( index < 0 || await confirm( 'Downloads are still in progress.\nClose application anyway?' ) ) {
                    this.ipc.send( 'quit' );
                }
            }
        }
        window.customElements.define(HakunekoJobs.is, HakunekoJobs);
    </script>

</dom-module>
